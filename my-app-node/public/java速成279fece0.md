# JAVA速成

## JAVA基础





### 常量和变量

变量分类：

按照数据类型分：8种基本数据类型 4种常见的引用类型

按照变量定义的位置分：成员变量 方法外类内 局部变量：方法内

### 运算符

算术运算符

### 选择与循环

#### 循环

while 

for 

do whie

for each

```java
for(数据类型 别名：代遍历元素){
	// 对别名的操作
    // 每次循环，别名代表的是当前循环制
    System.out.println(别名)
}
```



#### 选择

### 数组

1. 数组初始化
2. 数组声明规则
3. 数组常用方法

#### 初始化3种方式

### 重载和重写

#### 重载

重载是<font color=red>在一个类中</font>，写多个名字相同但参数不同的方法。

1. 必须在一个类中
2. 方法名相同
3. 参数不同：个数、顺序、类型
4. **与修饰符和返回值类型没关系**，如public、void等

#### 重写

重写场景：父类方法无法满足子类需求时，需要方法重写

重写注意事项：

1. 重写方法必须和父类一模一样（返回值类型、方法名、参数列表）

2. 重写的方法可以使用`@override`注解来标识，这样程序会检测重写是否正确

3. 访问权限：子类中重写方法的访问权限不能低于父类中方法的访问权限

   权限修饰符：private < 默认，什么都不写< protected< public

> 区分重载和重写
>
> - 重载：同一个类中，多个同名方法，参数不同，与修饰符无关
>
> - 重写：继承了父类的子类，与父类一模一样的方法，权限修饰符有要求

### this和super关键字

#### this

1. 构造方法中

   指向构造器所创建的新对象

2. 普通方法中指向该方法的调用对象

3. **类方法（非静态类方法）**或构造器中引用该类的实例变量

> 注意
>
> this只能在类的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。
>
> 原因：static方法在**类加载**时就已经存在了，但是对象在创建时才在内存中生成

#### super

用在子类方法，指向父类的对象，可以访问：`父类的属性、函数以及构造函数。`

```java
super.父类属性
super.父类方法名()
```

注意：

- 子类和父类中存在同名成员时，**在子类中默认是访问子类成**员；可以通过super关键字指定访问父类的成员。

- 如果子类中没有成员，而父类中有，需要写spuer.调用父类成员

  

### static/final

#### final

1.修饰类：final修饰的类不能被继承

2.修饰方法：final修饰的方法不能被重写；可以被子类的方法调用

3.修饰变量：

```java
// 1.基本类型变量用final修饰后不可再修改
// 2.引用数据类型被final修饰了：引用变量引用(地址)不可变，但是引用对象内容可变
```

### 抽象类

定义：用abstract修饰符修饰的类

抽象了里面可以有：实例变量、静态变量、`抽象方法、普通方法`

抽象方法：后面不能写花括号

抽象类不能声明新对象，所以里面使用

### 接口

`public interfce 接口名 `

1. `interfce`前必须是`public或默认`

2. 接口中**所有方法**都是抽象的 `public abstract`，所以定义方法时可以省略这两个修饰符

3. 接口中**变量**只能为`public static final`类型，所以也可以不写这三个修饰符

```java
public interface User{
    // 变量 两种写法等价
    public static final int age=99;
    int age=99;
    // 方法
    public abstract void add();
    void add();
}
```

> 区分接口和抽象类
>
> - 接口可以**多实现**，而抽象类只能**被单继承**
>
>   针对接口和抽象类：
>
>   - implements 后可写多个接口
>
>   - extends后只能写一个抽象类



